#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;

#define MAP_SIZE    24

int step_move[4][2] = {{ 1,  0},
                       {-1,  0},
                       {0 ,  1},
                       {0 , -1}};

double gps_move[4][2] = {{-0.125,      0},
                         {0.125 ,      0},
                         {0     ,  0.125},
                         {0     , -0.125}};

struct pos
{
    double x, y;
}robot;

struct step
{
    int x, y;
    int t;
    int way;
}step_now, step_temp;

struct solution
{
    struct step pos;
    vector<step> record;
}now, temp;

char map[MAP_SIZE][MAP_SIZE] =
{
	{'0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', 'E'},
	{'0', '0', '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '1', '1'},
	{'0', '0', '1', '1', '0', '0', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1'},
	{'0', '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0'},
	{'1', '1', '0', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0'},
	{'0', '0', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '1', '0'},
	{'0', '0', '1', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '1', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0'},
	{'1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0'},
	{'1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'1', '1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0'},
	{'0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0'},
	{'0', '0', '1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1', '0', '0'},
	{'0', '0', '1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0'},
	{'1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0'},
	{'1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0'},
	{'0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0'},
	{'S', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '0', '0'},
};

bool is_visited[MAP_SIZE][MAP_SIZE];
char route_type[4] = {'D', 'U', 'R', 'L'};
vector<pos> target;

solution bfs()
{
    queue<solution> q;
    q.push(now);
    while(!q.empty())
    {
        temp = q.front();
        q.pop();
        if(map[temp.pos.x][temp.pos.y] == 'E')
            return temp;
        
        for(int i = 0;i < 4;i++)
        {
            struct solution new_leaf;
            struct step new_step;
            int dx = temp.pos.x + step_move[i][0];
            int dy = temp.pos.y + step_move[i][1];
            if(dx >= 0 && dx < MAP_SIZE && dy >= 0 && dy < MAP_SIZE && map[dx][dy] != '1' && !is_visited[dx][dy])
            {
                new_step.x = dx;
                new_step.y = dy;
                new_step.t = temp.pos.t + 1;
                new_step.way = i;
                is_visited[new_step.x][new_step.y] = true;
                new_leaf.pos = new_step;
                new_leaf.record = temp.record;
                new_leaf.record.push_back(new_step);
                q.push(new_leaf);
            }
        }
    }
}

int main() 
{
    for(int i = 0;i < MAP_SIZE;i++)
        memset(is_visited[i], false, sizeof(is_visited[i]));

    step_now.x = 23;
    step_now.y = 0;
    step_now.t = 0;
    step_now.way = -1;
    now.pos = step_now;
    now.record.push_back(step_now);

    struct solution result = bfs();
    printf("step = %d\n", result.pos.t);

    robot.x = -1.4375;
    robot.y = -1.4375;
    target.push_back(robot);

    for(int i = 1;i < result.record.size();i++)
    {
        robot.x = robot.x + gps_move[result.record[i].way][0];
        robot.y = robot.y + gps_move[result.record[i].way][1];
        target.push_back(robot);
        printf("{%f, %f},\n", robot.x, robot.y);
    }
}
